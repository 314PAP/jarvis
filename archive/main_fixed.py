#!/usr/bin/env python3
"""
MyJarvis - ƒåesk√Ω hlasov√Ω asistent
Hlavn√≠ soubor podle README.md specifikace
"""

import asyncio
import logging
import yaml
import subprocess
import webbrowser
import urllib.parse
from datetime import datetime
import pyaudio
import numpy as np
import speech_recognition as sr

try:
    from llama_cpp import Llama

    LLM_OK = True
except ImportError:
    LLM_OK = False

try:
    import pvporcupine

    PORCUPINE_OK = True
except ImportError:
    PORCUPINE_OK = False

# Logging podle config
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(message)s")
logger = logging.getLogger("MyJarvis")


class MyJarvis:
    """Hlavn√≠ t≈ô√≠da podle README specifikace"""

    def __init__(self):
        logger.info("ü§ñ MyJarvis startuje...")

        self.audio = pyaudio.PyAudio()
        self.recognizer = sr.Recognizer()
        self.running = True
        self.porcupine = None
        self.llm = None
        self.wake_stream = None

        # Inicializace podle po≈ôad√≠ v README
        self.load_config()
        self.init_microphone()
        self.init_porcupine()
        self.init_llm()

    def load_config(self):
        """Naƒçten√≠ konfigurace podle README specifikace"""
        with open("config.yaml", "r", encoding="utf-8") as f:
            self.config = yaml.safe_load(f)

    def init_microphone(self):
        """Najdi nejlep≈°√≠ mikrofon podle config"""
        logger.info("üé§ Inicializuji mikrofon...")

        device_index = self.config["audio"].get("device_index")
        if device_index is not None:
            self.mic_device = device_index
            info = self.audio.get_device_info_by_index(device_index)
            logger.info("‚úÖ Mikrofon (config): %s", info["name"])
            return

        # Automatick√° detekce
        for i in range(self.audio.get_device_count()):
            try:
                info = self.audio.get_device_info_by_index(i)
                if info["maxInputChannels"] > 0:
                    # Test mikrofonu s parametry z config
                    stream = self.audio.open(
                        format=pyaudio.paInt16,
                        channels=self.config["audio"]["channels"],
                        rate=16000,  # Porcupine vy≈æaduje 16kHz
                        input=True,
                        input_device_index=i,
                        frames_per_buffer=self.config["wake_word"]["chunk_size"],
                    )
                    stream.close()
                    self.mic_device = i
                    logger.info("‚úÖ Mikrofon (auto): %s", info["name"])
                    return
            except Exception:
                continue

        logger.error("‚ùå ≈Ω√°dn√Ω funkƒçn√≠ mikrofon!")
        self.mic_device = None

    def init_porcupine(self):
        """Inicializace Porcupine podle config"""
        if not PORCUPINE_OK:
            logger.warning("‚ö†Ô∏è Porcupine nedostupn√Ω - wake word vypnut")
            return

        try:
            wake_config = self.config["wake_word"]
            self.porcupine = pvporcupine.create(
                access_key=wake_config["access_key"],
                keyword_paths=[wake_config["model_path"]],
                sensitivities=[wake_config["threshold"]],
            )

            # Vytvo≈ô kontinu√°ln√≠ stream pro wake word
            if self.mic_device is not None:
                self.wake_stream = self.audio.open(
                    format=pyaudio.paInt16,
                    channels=1,
                    rate=16000,
                    input=True,
                    input_device_index=self.mic_device,
                    frames_per_buffer=self.porcupine.frame_length,
                )

            logger.info("‚úÖ Wake word aktivn√≠: '%s'", wake_config["keyword"])

        except Exception as e:
            logger.error("‚ùå Porcupine chyba: %s", e)
            self.porcupine = None

    def init_llm(self):
        """Inicializace LLM podle config"""
        if not LLM_OK:
            logger.warning("‚ö†Ô∏è LLM nedostupn√Ω")
            return

        try:
            llm_config = self.config["llm"]
            self.llm = Llama(
                model_path=llm_config["model_path"],
                n_ctx=llm_config["n_ctx"],
                n_threads=llm_config["n_threads"],
                verbose=False,
            )
            logger.info("‚úÖ LLM naƒçten (%s)", llm_config["model_path"].split("/")[-1])
        except Exception as e:
            logger.error("‚ùå LLM chyba: %s", e)

    def detect_wake_word(self):
        """Kontinu√°ln√≠ detekce wake word pomoc√≠ stream"""
        if not self.porcupine or not self.wake_stream:
            return False

        try:
            # ƒåti z kontinu√°ln√≠ho streamu
            audio_data = self.wake_stream.read(
                self.porcupine.frame_length, exception_on_overflow=False
            )

            # Konverze na numpy array
            audio_np = np.frombuffer(audio_data, dtype=np.int16)

            # Porcupine detekce
            keyword_index = self.porcupine.process(audio_np)

            return keyword_index >= 0

        except Exception as e:
            logger.debug("Wake word detekce chyba: %s", e)
            return False

    def listen_for_command(self):
        """Poslech p≈ô√≠kazu po aktivaci wake word"""
        if not self.mic_device:
            return None

        try:
            # Doƒçasnƒõ zav≈ôi wake word stream
            if self.wake_stream:
                self.wake_stream.close()
                self.wake_stream = None

            # Kr√°tk√° pauza pro uvolnƒõn√≠ za≈ô√≠zen√≠
            import time

            time.sleep(0.1)

            # Pou≈æij speech_recognition s parametry z config
            mic = sr.Microphone(device_index=self.mic_device)
            stt_config = self.config["stt"]

            with mic as source:
                # D≈ÆLE≈ΩIT√â: Adaptivn√≠ kalibrace podle prost≈ôed√≠
                logger.info("üîß Kalibrace mikrofonu...")
                self.recognizer.adjust_for_ambient_noise(source, duration=0.5)

                # Pou≈æij p≈ôesnƒõ hodnoty z config - NE max()!
                self.recognizer.energy_threshold = stt_config["energy_threshold"]
                self.recognizer.dynamic_energy_threshold = stt_config[
                    "dynamic_energy_threshold"
                ]
                # Del≈°√≠ pauza pro rozpozn√°n√≠ cel√Ωch vƒõt
                self.recognizer.pause_threshold = 1.2

                logger.info(
                    "üé§ Poslouch√°m p≈ô√≠kaz... (threshold: %d)",
                    self.recognizer.energy_threshold,
                )

                # Poslech s optimalizovan√Ωmi timeouty
                logger.info("üéß Zaƒç√≠n√°m poslouchat...")
                audio = self.recognizer.listen(
                    source,
                    timeout=stt_config["timeout"],
                    phrase_time_limit=stt_config["phrase_timeout"],
                )

                logger.info("üéôÔ∏è Audio zachyceno, p≈ôepisuji...")
                # STT s ƒçeskou lokalizac√≠
                text = self.recognizer.recognize_google(
                    audio, language=stt_config["language"]
                )

                result = text.strip()
                logger.info("‚úÖ Rozpozn√°no: %s", result)

        except sr.WaitTimeoutError:
            logger.info("‚è∞ ƒåasov√Ω limit pro p≈ô√≠kaz - pokraƒçuji v poslouch√°n√≠")
            result = None
        except sr.UnknownValueError:
            logger.info("üîá Nerozpoznan√Ω audio - zkuste mluvit hlasitƒõji")
            result = None
        except sr.RequestError as e:
            logger.error("STT slu≈æba nedostupn√°: %s", e)
            result = None
        except Exception as e:
            logger.error("STT chyba: %s", e)
            logger.error("STT chyba detaily: %s", type(e).__name__)
            result = None

        finally:
            # V≈ædy obnov wake word stream
            self.restore_wake_stream()

        return result

    def restore_wake_stream(self):
        """Obnov wake word stream po STT"""
        if self.porcupine and self.mic_device is not None:
            try:
                # Kr√°tk√° pauza p≈ôed obnoven√≠m
                import time

                time.sleep(0.2)

                self.wake_stream = self.audio.open(
                    format=pyaudio.paInt16,
                    channels=1,
                    rate=16000,
                    input=True,
                    input_device_index=self.mic_device,
                    frames_per_buffer=self.porcupine.frame_length,
                )
                logger.debug("Wake word stream obnoven")
            except Exception as e:
                logger.error("Chyba obnoven√≠ wake word stream: %s", e)

    def speak(self, text):
        """TTS podle config"""
        try:
            tts_config = self.config["tts"]
            logger.info("üó£Ô∏è %s", text)

            if tts_config["service"] == "espeak":
                cmd = [
                    "espeak",
                    "-v",
                    tts_config["voice"],
                    "-s",
                    str(tts_config["speed"]),
                    "-a",
                    str(tts_config["volume"]),
                    "-p",
                    str(tts_config["pitch"]),
                    "-g",
                    str(tts_config["gap"]),
                    text,
                ]
                subprocess.run(
                    cmd,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    check=False,
                )

        except Exception as e:
            logger.error("TTS chyba: %s", e)

    def generate_ai_response(self, text):
        """Generuj odpovƒõƒè pomoc√≠ LLM"""
        if not self.llm:
            return "LLM nen√≠ dostupn√Ω"

        try:
            llm_config = self.config["llm"]

            # Lep≈°√≠ ƒçesk√Ω prompt
            prompt = f"""Ot√°zka: {text}
Odpovƒõz ƒçesky jednodu≈°e a struƒçnƒõ.
Odpovƒõƒè:"""

            response = self.llm(
                prompt,
                max_tokens=llm_config["max_tokens"],
                temperature=llm_config["temperature"],
                stop=["\n", "Ot√°zka:", "Odpovƒõz:"],
            )

            answer = response["choices"][0]["text"].strip()

            # Filtrov√°n√≠
            if len(answer) > 3 and answer:
                return answer
            else:
                return "Nerozum√≠m t√©to ot√°zce"

        except Exception as e:
            logger.debug("LLM chyba: %s", e)
            return "Promi≈àte, moment√°lnƒõ nemohu odpovƒõdƒõt"

    def handle_system_command(self, text):
        """Syst√©mov√© p≈ô√≠kazy s bezpeƒçnostn√≠mi kontrolami"""
        text_lower = text.lower()

        # Ukonƒçen√≠
        if any(
            word in text_lower for word in ["konec", "stop", "ukonƒçit", "vypni jarvis"]
        ):
            self.speak("P≈ôech√°z√≠m do wake word re≈æimu")
            return True

        # ƒåas
        if any(word in text_lower for word in ["ƒças", "hodin", "kolik je"]):
            now = datetime.now()
            response = f"Je {now.hour} hodin a {now.minute:02d} minut"
            self.speak(response)
            return False

        # Vypnut√≠ syst√©mu (s potvrzen√≠m podle README)
        if "vypni poƒç√≠taƒç" in text_lower:
            self.speak("Opravdu chcete vypnout poƒç√≠taƒç? ≈òeknƒõte ano pro potvrzen√≠")
            confirm = self.listen_for_command()
            if confirm and "ano" in confirm.lower():
                self.speak("Vyp√≠n√°m poƒç√≠taƒç")
                subprocess.run(["systemctl", "poweroff"], check=False)
            else:
                self.speak("Vypnut√≠ zru≈°eno")
            return False

        # Firefox
        if any(word in text_lower for word in ["firefox", "prohl√≠≈æeƒç", "internet"]):
            self.speak("Spou≈°t√≠m Firefox")
            subprocess.Popen(
                ["firefox"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
            )
            return False

        # Vyhled√°v√°n√≠ (podle README)
        if any(word in text_lower for word in ["najdi", "vyhledej", "hledej"]):
            # Extrakce dotazu
            query = text_lower
            for word in ["najdi", "vyhledej", "hledej", "na", "internetu"]:
                query = query.replace(word, "")
            query = query.strip()

            if query:
                self.speak(f"Vyhled√°v√°m {query}")
                url = f"https://www.google.com/search?q={urllib.parse.quote(query)}"
                webbrowser.open(url)
                self.speak("V√Ωsledky jsou otev≈ôen√© v prohl√≠≈æeƒçi")
            else:
                self.speak("Co m√°m vyhledat?")
            return False

        return None  # Nen√≠ syst√©mov√Ω p≈ô√≠kaz

    async def main_loop(self):
        """Hlavn√≠ smyƒçka podle README specifikace"""
        logger.info("‚úÖ MyJarvis p≈ôipraven!")

        if self.porcupine:
            logger.info(
                "üëÇ ƒåek√°m na wake word: '%s'", self.config["wake_word"]["keyword"]
            )
        else:
            logger.info("üëÇ Wake word nen√≠ dostupn√Ω - kontinu√°ln√≠ poslech")

        try:
            while self.running:
                if self.porcupine:
                    # Re≈æim wake word
                    if self.detect_wake_word():
                        logger.info("üéØ Wake word detekov√°n!")
                        self.speak("Ano, poslouch√°m")

                        # Poslech p≈ô√≠kazu
                        command = self.listen_for_command()
                        if command:
                            logger.info("üë§ P≈ô√≠kaz: %s", command)

                            # Zpracov√°n√≠ syst√©mov√Ωch p≈ô√≠kaz≈Ø
                            sys_result = self.handle_system_command(command)
                            if sys_result is True:
                                # N√°vrat do wake word re≈æimu
                                logger.info(
                                    "üëÇ ƒåek√°m na wake word: '%s'",
                                    self.config["wake_word"]["keyword"],
                                )
                                continue
                            elif sys_result is False:
                                # Syst√©mov√Ω p≈ô√≠kaz byl vykon√°n - pokraƒçuj v wake word re≈æimu
                                logger.info(
                                    "üëÇ ƒåek√°m na wake word: '%s'",
                                    self.config["wake_word"]["keyword"],
                                )
                                continue
                            else:
                                # Nen√≠ syst√©mov√Ω - pou≈æij AI
                                response = self.generate_ai_response(command)
                                self.speak(response)
                                logger.info(
                                    "üëÇ ƒåek√°m na wake word: '%s'",
                                    self.config["wake_word"]["keyword"],
                                )
                                continue
                        else:
                            self.speak("Nerozumƒõl jsem, zkuste to znovu")
                            logger.info(
                                "üëÇ ƒåek√°m na wake word: '%s'",
                                self.config["wake_word"]["keyword"],
                            )
                            continue

                    # Kr√°tk√° pauza pro CPU
                    await asyncio.sleep(0.01)

                else:
                    # Fallback - bez wake word
                    self.speak("≈ò√≠kejte p≈ô√≠kazy")
                    command = self.listen_for_command()
                    if command:
                        logger.info("üë§ %s", command)
                        sys_result = self.handle_system_command(command)
                        if sys_result is True:
                            break
                        elif sys_result is None:
                            response = self.generate_ai_response(command)
                            self.speak(response)
                    await asyncio.sleep(1)

        except KeyboardInterrupt:
            logger.info("‚èπÔ∏è Ukonƒçov√°n√≠ MyJarvis...")
        finally:
            self.cleanup()

    def cleanup(self):
        """√öklid zdroj≈Ø"""
        if self.wake_stream:
            self.wake_stream.close()
        if self.porcupine:
            self.porcupine.delete()
        if self.audio:
            self.audio.terminate()
        logger.info("‚úÖ MyJarvis ukonƒçen")


def main():
    """Hlavn√≠ funkce podle README"""
    print("ü§ñ MyJarvis - ƒåesk√Ω Hlasov√Ω Asistent")
    print("=" * 50)
    print(f"üìñ ≈òeknƒõte: 'hello bitch' pro aktivaci")
    print(f"üó£Ô∏è Pak libovoln√Ω p≈ô√≠kaz ƒçesky")
    print(f"üõë 'konec' = n√°vrat do wake word re≈æimu")
    print("=" * 50)

    try:
        jarvis = MyJarvis()
        asyncio.run(jarvis.main_loop())
    except Exception as e:
        logger.error("Kritick√° chyba: %s", e)
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    main()
